from math import log10
from typing import Callable, Iterable


nominals = {
    'E6': (
        10, 15, 22, 33, 47, 68
    ),
    'E12': (
        10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82
    ),
    'E24': (
        10, 11, 12, 13, 15, 16, 18, 20, 22, 24, 27, 30, 33, 36, 39, 43, 47, 51, 56, 62, 68, 75, 82, 91
    ),
    'E48': (
        100, 105, 110, 115, 121, 127, 133, 140, 147, 154, 162, 169, 178, 187, 196, 205, 215, 226, 237, 249, 261, 274, 287, 301, 316, 332, 348, 365, 383, 402, 422, 442, 464, 487, 511, 536, 562, 590, 619, 649, 681, 715, 750, 787, 825, 866, 909, 953
    ),
    'E96': (
        100, 102, 105, 107, 110, 113, 115, 118, 121, 124, 127, 130, 133, 137, 140, 143, 147, 150, 154, 158, 162, 165, 169, 174, 178, 182, 187, 191, 196, 200, 205, 210, 215, 221, 226, 232, 237, 243, 249, 255, 261, 267, 274, 280, 287, 294, 301, 309, 316, 324, 332, 340, 348, 357, 365, 374, 383, 392, 402, 412, 422, 432, 442, 453, 464, 475, 487, 499, 511, 523, 536, 549, 562, 576, 590, 604, 619, 634, 649, 665, 681, 698, 715, 732, 750, 768, 787, 806, 825, 845, 866, 887, 909, 931, 953, 976
    )
}


# ИСПОЛЬЗОВАТЬ: кажется, функция возвращает всё-таки не float, а tuple из двух float
def om_to_precision(input_om: str) -> tuple[float, float]:
    # ИСПОЛЬЗОВАТЬ: в абсолютном большинстве случаев мы и так знаем, что читаем документацию к функции, так что не стоит напрасно тратить символы docstring, а стоит сразу начинать описание с глагола
    #  есть разные стили оформления строки документации, но все они сходятся на том, что первая строка документации должна быть насколько возможно лаконичной и должна отвечать на вопрос "что делает?"
    #  описания параметров даются ниже: либо обычным текстом, либо специальным синтаксисом
    #  предложения не разбиваются посередине символом конца строки — используйте перенос строк (soft wrap) в редакторе
    """Масштабирует значение необходимого сопротивления для соответствия порядкам значений в разных рядах номиналов сопротивлений.

    :param input_om: необходимое сопротивление в Омах
    :returns: кортеж из двузначного и трёхзначного чисел
    """
    # КОММЕНТАРИЙ: очень порадовало, что стараетесь учесть и множители тоже
    # ИСПОЛЬЗОВАТЬ: не стоит, однако, усложнять — эту часть можно написать заметно проще
    input_om = float(input_om)
    if input_om < 1 or 10**8 < input_om:
        raise ValueError('резисторы с сопротивлением менее 1 Ом и более 100 МОм не учитываются данным стандартом')
    else:
        # ИСПОЛЬЗОВАТЬ: как же хорошо, что есть логарифмы
        input_om_exp = int(log10(input_om))
        # ИСПОЛЬЗОВАТЬ: для большей точности приведём к нужным порядкам по отдельности
        low = input_om * 10**(1 - input_om_exp)
        high = input_om * 10**(2 - input_om_exp)
    return low, high


def mymap(function: Callable, iterator: Iterable) -> list:
    # ИСПРАВИТЬ: строку документации — особое внимание обратить на то, что функция должна принять ровно два аргумента, это важно
    """Возвращает список, заполненный данными рассчитанными вложенной функцией.
       function: функция, производящая обработку каждого из элементов итерируемого объекта. 
       iterator: итерируемый объект.
    """
    ret = []
    for elem in iterator:
        ret.append(function(elem, param))
    return ret


# ИСПОЛЬЗОВАТЬ: если мы ожидаем int или float, то достаточно в аннотации указать float — поскольку числовые объекты могут использоваться смешанным образом
def diffs_nom_prec(nom: int, prec: float) -> float:
    # ИСПРАВИТЬ: строку документации
    """Возвращает разность принятых на вход номинала и значения, рассчитанного из введенных пользователем данных.
       nom: номинал из таблицы номиналов.
       prec: отмасштабированное значение необходимого сопротивления.
    """
    return abs(nom - prec)


om = input('Введите необходимое сопротивление: ')
precision = om_to_precision(om)

diffs = {}
for eia in nominals:
    if eia in ('E6', 'E12', 'E24'):
        param = precision[0]
    else:
        param = precision[1]
    diffs[eia] = mymap(diffs_nom_prec, nominals[eia])

result = {}
for eia in diffs:
    min_diff = min(diffs[eia])
    curr_index = diffs[eia].index(min_diff)
    if diffs[eia].count(min_diff) == 1:
        # ДОБАВИТЬ: вот чего здесь не хватает, так это умножения номинала на соответствующий множитель, чтобы порядок номинала совпал с порядком необходимого сопротивления
        # Здесь не уловил - ведь функция om_to_precision и так приводит порядок введенного значения к порядку номинала?
        result[eia] = nominals[eia][curr_index]
    else:
        result[eia] = [nominals[eia][curr_index]]
        result[eia] += [nominals[eia][curr_index + 1]]
                
print(result)        


# stdout:

# Введите необходимое сопротивление: 135
# {'E6': 15, 'E12': [12, 15], 'E24': 13, 'E48': 133, 'E96': [133, 137]}

# Введите необходимое сопротивление: 987
# {'E6': 68, 'E12': 82, 'E24': 91, 'E48': 953, 'E96': 976}

# Введите необходимое сопротивление: 1.3
# {'E6': 15, 'E12': 12, 'E24': 13, 'E48': [127, 133], 'E96': 130}

# Введите необходимое сопротивление: 0.123456
# {'E6': 10, 'E12': 12, 'E24': 12, 'E48': 121, 'E96': 124}


# ИТОГ: задача не тривиальная, но вы справились почти идеально — 10/12
