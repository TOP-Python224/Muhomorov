months = {
    1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31
}

# КОММЕНТАРИЙ: несоответствие аннотации возвращаемого типа и типа возвращаемого значения
def ordinalDate(day: int, month: int, year: int) -> int:
    # ИСПРАВИТЬ: по образцу из 08.29 и 08.31 (можно без подробного описания параметров, главное — первая строка)
    """Возвращает порядковый номер дня в году, рассчитанный из прининятых на вход дня, месяца и года."""
    if not year % 4 and year % 100 or not year % 400:
        months[2] = 29

    if 0 < day <= months[month]:
        # ИСПРАВИТЬ: какой-то из циклов лишний (возможно, оба)
        # Можно так:
        # days = day
        # for m in range(1, month):
        #     days += months[m]
        # А лучше так:
        days = day + sum(list(months.values())[:month-1])
        # ИСПРАВИТЬ: такие подписи мы выводим с помощью кода верхнего уровня, не функции — у вас в документации и аннотации заявлено, что функция возвращает порядковый номер дня, вот пусть его и возвращает
        return days
    else:
        # ИСПОЛЬЗОВАТЬ: здесь лучше выбросить исключение
        raise ValueError(f"Введено неправильное количество дней ({day}) в месяце ({month})")


if __name__ == '__main__':
    day = int(input('Введите день: '))
    month = int(input('Введите месяц: '))
    year = int(input('Введите год: '))
    print(ordinalDate(day, month, year))


# stdout:
# Введите день: 0
# Введите месяц: 1
# Введите год: 2020
# ведено неправильное количество дней (0) в месяце (1)!

# Введите день: 29
# Введите месяц: 02
# Введите год: 20119
# Введено неправильное количество дней (29) в месяце (2)!

# Введите день: 29
# Введите месяц: 02
# Введите год: 2020
# Порядковый номер дня: 60


# ИТОГ: небольшие погрешности, но в целом хорошо — 3/4
